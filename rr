import pandas as pd
import json
import ast

INPUT_FILE = "input.xlsx"
OUTPUT_FILE = "output_processed.xlsx"


CLIENT_COL_CANDIDATES = ["client", "Client", "CLIENT"]


DELIM = ".\n\n"

CLAUSE_TEXT_COL = "extracted_clauses_text"
CLAUSE_SECTIONS_COL = "extracted_clauses_sections"  

# Output column base name requirement
OUT_BASE = "extracted_clauses" 


def safe_parse_dict(cell):
   
    if pd.isna(cell):
        return None
    if isinstance(cell, dict):
        return cell
    if not isinstance(cell, str):
        return None
    s = cell.strip()
    if not (s.startswith("{") and s.endswith("}")):
        return None

    try:
        return json.loads(s)
    except Exception:
        pass
    try:
        return ast.literal_eval(s)  # handles single quotes
    except Exception:
        return None


def to_list_preserve_order(x):
    
    if x is None:
        return []
    if isinstance(x, (list, tuple)):
        return list(x)
    if isinstance(x, dict):
        keys = list(x.keys())
        if all(isinstance(k, str) and k.isdigit() for k in keys):
            return [x[k] for k in sorted(keys, key=lambda k: int(k))]
        return list(x.values())
    return [x]


def clean_content_extracted(text):
    
    if text is None:
        return ""
    if not isinstance(text, str):
        text = str(text)
    idx = text.find(DELIM)
    if idx == -1:
        return text.strip()
    return text[idx + len(DELIM):].lstrip()


def extract_content_parts(d):
    
    if not isinstance(d, dict):
        return []
    raw = d.get("content_extracted", "")
    parts = []
    for item in to_list_preserve_order(raw):
        if item is None:
            continue
        cleaned = clean_content_extracted(item)
        if cleaned:
            parts.append(cleaned)
    return parts


def extract_source_parts(d):
    """Return list of sources parts (supports scalar/list/dict)."""
    if not isinstance(d, dict):
        return []
    raw = d.get("sources", "")
    parts = []
    for item in to_list_preserve_order(raw):
        if item is None:
            continue
        if isinstance(item, (dict, list)):
            parts.append(json.dumps(item, ensure_ascii=False))
        else:
            s = str(item).strip()
            if s:
                parts.append(s)
    return parts


def join_nonempty(items, sep):
    items = [x.strip() for x in items if isinstance(x, str) and x.strip()]
    return sep.join(items).strip()


def rag_col_name(i: int) -> str:
    
    return f"{OUT_BASE}_RAG" if i == 0 else f"{OUT_BASE}{i+1}_RAG"


def process_excel(input_file, output_file):
    df = pd.read_excel(input_file)

    client_col = next((c for c in CLIENT_COL_CANDIDATES if c in df.columns), None)

    has_clause_text = CLAUSE_TEXT_COL in df.columns
    has_clause_sections = CLAUSE_SECTIONS_COL in df.columns

    output_rows = []
    all_rag_cols = set()

    for _, row in df.iterrows():
        
        content_row = row.to_dict()
        sources_row = row.to_dict()
        content_row["row_type"] = "content"
        sources_row["row_type"] = "sources"

        
        for col in df.columns:
            if col == client_col:
                continue
            if col in (CLAUSE_TEXT_COL, CLAUSE_SECTIONS_COL):
                continue

            d = safe_parse_dict(row[col])
            if not isinstance(d, dict):
                continue

            
            content_parts = extract_content_parts(d)
            source_parts = extract_source_parts(d)

            content_row[col] = join_nonempty(content_parts, "\n\n")
            sources_row[col] = join_nonempty(source_parts, "\n")

        
        if has_clause_text:
            text_d = safe_parse_dict(row[CLAUSE_TEXT_COL])
            text_parts = extract_content_parts(text_d)
            text_src_parts = extract_source_parts(text_d)

            sect_parts = []
            sect_src_parts = []
            if has_clause_sections:
                sect_d = safe_parse_dict(row[CLAUSE_SECTIONS_COL])
                
                raw_sect = sect_d.get("content_extracted", "") if isinstance(sect_d, dict) else ""
                sect_parts = [str(x).strip() for x in to_list_preserve_order(raw_sect) if x is not None and str(x).strip()]
                sect_src_parts = extract_source_parts(sect_d)

            n = max(len(text_parts), len(sect_parts), 1)

            for i in range(n):
                colname = rag_col_name(i)
                all_rag_cols.add(colname)

                t = text_parts[i] if i < len(text_parts) else ""
                s = sect_parts[i] if i < len(sect_parts) else ""

                
                content_row[colname] = join_nonempty([t, s], "\n\n")

                tsrc = text_src_parts[i] if i < len(text_src_parts) else ""
                ssrc = sect_src_parts[i] if i < len(sect_src_parts) else ""
                sources_row[colname] = join_nonempty([tsrc, ssrc], "\n")

            
            content_row.pop(CLAUSE_TEXT_COL, None)
            sources_row.pop(CLAUSE_TEXT_COL, None)
            if has_clause_sections:
                content_row.pop(CLAUSE_SECTIONS_COL, None)
                sources_row.pop(CLAUSE_SECTIONS_COL, None)

        output_rows.append(content_row)
        output_rows.append(sources_row)

    df_out = pd.DataFrame(output_rows)

    
    for c in sorted(all_rag_cols, key=lambda x: (len(x), x)):
        if c not in df_out.columns:
            df_out[c] = ""

    
    cols = list(df_out.columns)
    ordered = []

    if client_col and client_col in cols:
        ordered.append(client_col)
    if "row_type" in cols:
        ordered.append("row_type")

    rag_cols_sorted = []
    
    def rag_index(name):
        
        tail = name.replace(f"{OUT_BASE}", "").replace("_RAG", "")
        return 1 if tail == "" else int(tail)

    rag_cols_sorted = sorted([c for c in cols if c.endswith("_RAG") and c.startswith(OUT_BASE)], key=rag_index)
    ordered.extend(rag_cols_sorted)

    # add remaining columns
    for c in cols:
        if c not in ordered:
            ordered.append(c)

    df_out = df_out[ordered]
    df_out.to_excel(output_file, index=False)
    print(f"Saved: {output_file}")


if __name__ == "__main__":
    process_excel(INPUT_FILE, OUTPUT_FILE)
