def make_chunks_for_pdf(pdf_path: Path, category: str, client_id: str) -> Iterable[Document]:
    """
    PDF chunking:
      - If the PDF looks scanned (no extractable text), fall back to Textract (S3-backed).
      - Otherwise extract text with PyMuPDF (fitz), then chunk across pages while tracking page ranges.
    """
    policy_id = pdf_path.name

    # 1) Decide whether to use OCR/Textract
    try:
        scanned = is_scanned_pdf(pdf_path)
    except Exception:
        scanned = True

    if scanned:
        # Textract loader path (requires local->S3 mapping + correct bucket/prefix)
        yield from _yield_textract_chunks_with_loader(pdf_path, category, client_id, policy_id)
        return

    # 2) Digital PDF: extract per-page text with PyMuPDF and build page_ranges
    try:
        with fitz.open(str(pdf_path)) as doc:
            concatenated = ""
            page_ranges: List[Tuple[int, int, int]] = []  # (start_char, end_char, page_num)
            cursor = 0

            for i in range(doc.page_count):
                page = doc.load_page(i)
                txt = clean_text(page.get_text("text") or "")
                if not txt:
                    continue

                start = cursor
                concatenated += txt + "\n"
                cursor = len(concatenated)
                page_ranges.append((start, cursor, i + 1))
    except Exception as e:
        print(f"[WARN] Failed to read PDF {pdf_path} with PyMuPDF: {e}")
        # As a fallback, try Textract
        yield from _yield_textract_chunks_with_loader(pdf_path, category, client_id, policy_id)
        return

    # 3) If PyMuPDF gave us nothing, fallback to Textract
    if not concatenated.strip():
        yield from _yield_textract_chunks_with_loader(pdf_path, category, client_id, policy_id)
        return

    # 4) Chunk across the concatenated text and preserve page_start/page_end
    for c_start, c_end, chunk in chunk_text(concatenated):
        pages = sorted({
            page_num
            for p_start, p_end, page_num in page_ranges
            if not (p_end <= c_start or p_start >= c_end)
        })
        if not pages:
            continue

        meta = {
            "category": category,
            "client_id": client_id,
            "policy_id": policy_id,
            "page_start": pages[0],
            "page_end": pages[-1],
            "source_file": str(pdf_path.resolve()),
            "extracted_by": "pymupdf",
        }
        yield Document(page_content=chunk, metadata=meta)
